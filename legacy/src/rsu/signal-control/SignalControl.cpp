
//MMITSS MRP Adaptive Signal Control Component


//Yiheng Fneg 09/19/2014

//Department of Systems and Industrial Engineering
//University of Arizona
           
        
// Work with Vissim 6.0 DriverModel through UDP
// Need drivermodel_udp_R.dll from "DriverModel_DLL_UDP_InFusion" running
//#include <libeloop.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <getopt.h>
#include <unistd.h>
                         
#include <iostream>
#include <string>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fstream>
#include <sstream>
#include <istream>
#include "math.h"
#include "time.h"
#include <time.h>
#include <vector>
#include <sys/time.h>

#include <iomanip>
#include <stddef.h>
#include <dirent.h>

#include "Mib.h"
#include "LinkedList.h"
#include "ListHandle.h"
#include "Signal.h"
#include "Array.h"
#include "Config.h"   // <vector>
#include "Print2Log.h"
#include "GetInfo.h"
//#include "COP.h"
#include "COP_DUAL_RING.h"
#include "Schedule.h"
//#include "ConnectedVehicle.h"
#include "EVLS.h"
          
using namespace std;

#ifndef BSM_MSG_SIZE
    #define BSM_MSG_SIZE  (45)
#endif

#ifndef DEG2ASNunits
    #define DEG2ASNunits  (1000000.0)  // used for ASN 1/10 MICRO deg to unit converts
#endif

#ifndef byte
    #define byte  char  // needed if byte not defined
#endif

//socket settings
#define PRPORT 15020
//#define OBU_ADDR "192.168.1.25"
#define BROADCAST_ADDR "192.168.101.255"   //DSRC

#define EV  1
#define TRANSIT 2

#define ACTIVE 1
#define NOT_ACTIVE -1
#define LEAVE 0

#define PI 3.14159265

char vehicleid [64];
//char buf[256];
string RSUID_Pre,RSUID_Cur;
RSU_Config ConfigIS;

char temp_log[512];
int continue_while=0;

PhaseStatus phase_read={0};   // value would be {1,3,4}
int CurPhaseStatus[8]={0};    // when do phaseReading: the same results as phase_read withoug conversion

//define log file name
char predir [64] = "/nojournal/bin/";
char logfilename[256] = "/nojournal/bin/log/MMITSS_rsu_Signal_Control_";
char rndf_file[64]="/nojournal/bin/RNDF.txt";
char active_rndf_file[128]="/nojournal/bin/ActiveRNDF.txt";
char ConfigInfo[256]	  = "/nojournal/bin/ConfigInfo.txt";
char arrivaltablefile[256]="/nojournal/bin/ArrivalTable.txt";
char SignalTimingData[256]="/nojournal/bin/SignalTiming.txt";
char Lane_No_File_Name[64]  = "/nojournal/bin/Lane_No.txt";

int  outputlog(char *output);
//void get_ip_address();           // READ the virtual ASC controller IP address into INTip from "IPInfo.txt"


//This is the output of the FindVehInMap
double Dis_curr=0;  //current distance to the stop bar
double ETA=0;       //estimated travel time to stop bar
int requested_phase=-1;  //requested phase

//for NTCIP signal control

char IPInfo[64]="/nojournal/bin/ntcipIP.txt";  //stores the virtual asc3 Controller IP address
char INTip[64];
char INTport[8];   //this port is for the virtual controller
int CombinedPhase[8]={0};

Phase Phases;  //----Important one----//

string RSUID;
char rsuid_filename[64]   = "/nojournal/bin/rsuid.txt";
char ConfigFile[256];
char Signal_Configure_COP_File[256]= "/nojournal/bin/Signal_Config_COP.txt";

//Parameters for EVLS
float penetration=0.5;      //penetration rate
float dsrc_range=200;



//Parameters for trajectory control
int ArrivalTable[131][8];     //maximum planning time horizon * number of phases
//int opt_s[3];   //COP optimized phase duration
int previous_phase[2];  //previous phases of the two rings, either one ring advanced, the previous_phases need to be updated,used to calculate passed phases. [1-8]
int passed_phase[2];    //passed phase in the same ring, [0-7];
int skip_phase[8]; //if no vehicle arrives for a phase, then this phase can be skipped.
int hold_timer;  //timer to hold the phase;
int currenttime;
int opt_sig_plan[2][2*2];  //the optimal signal plan of 3 barriers generated by DUAL RING COP
int opt_sig_seq[2][2*2];  //the optimal signal sequence of 3 barriers generated by DUAL RING COP

int occupancy[8];    //occupancy value of the detector at stop bar (using as the system detector)

int Phase_Num;
int phase_seq[8];

int MinGreen[8];
int MaxGreen[8];
int Yellow[8];
int Red[8];
int PedWalk[8];
int PedClr[8];
int Ped_Info[2];    //[0]: ped status, [1]: ped call in integer number;
int Ped_Phase_Considered[8]={0};   //Which ped phase need to be considered in the COP, 1:yes, 0: no;
int queue_warning_P1=0;      //0 if left turn phases have queuing vehicle <10; 1 if else  This flag is used to prevent queue spill back from left turn bay.
int queue_warning_P5=0;


int InitPhase[2], CurrPhase[2];
double InitTime[2],GrnElapse[2];

double red_elapse_time[8];   //Red elapse time of each phase

int delay_type=0;    //Type of objective function that used in COP; 0= total delay 1=average vehicle delay


int LaneNo[8];   //This is the number of lanes of each phase, this determines discharging rate

LinkedList <Schedule> Eventlist_R1;
LinkedList <Schedule> Eventlist_R2;

//Parameters for get trajectory data
char buf_traj[500000];  //The Trajectory message from MRP_EquippedVehicleTrajecotryAware
LinkedList <ConnectedVehicle> trackedveh;
LinkedList <ConnectedVehicle> vehlist_each_phase;

     
void UnpackTrajData1(char* ablob);  //This function unpack the trajectory message and save to trackedveh list;

int COP_Intersectioncontrol(int InitPhase[2], int planed_phases, int opt_timing[12]);
int Find_Passed_Phase_In_Same_Barrier(int pre_phase[2], int cur_phase[2]);    //find the passed phase in the same barrier, for COP stage 1 planning
int Construct_eventlist(int opt_sig_plan[2][4], int cur_phase[2]);        //construct the event list for signal control
int Conflit_call(int currphase[2], int skipphase[8]);    //find out whether there is vehicle arrives at conflict phase, return 1 if yes, 0 if no.
void get_lane_no();   //get number of lanes each phase from Lane_No.txt file
void ReadSignalParameters(char *ConfigFile);
int Check_Ped_Phase_Info();     //Check the current ped status and ped call to get the which ped phase needs to be included when planning COP
void Pack_Event_List(byte* tmp_event_data,int &size);
int Complete_Barrier();        //Add missing phase to complete the barrier (modify skip_phases)

int Checkconflict(int CurPhase[2]);  //Check whether the current phase is conflict
int ModifyCurPhase(int CurrPhase[2], int phase_seq[8]);  //If current phase is in conflict state, modify the current phase in one ring

int main ( int argc, char* argv[] )
{

	int UDP_PORT=30000;

	ConnectedVehicle temp_veh;
	
	double lower_ETA=6; //default value
	double upper_ETA=8;


	char timestamp[128];
    xTimeStamp(timestamp);
    strcat(logfilename,timestamp);    
    strcat(logfilename,".log");
	
	printf("%s\n",logfilename);
	
	fstream fs_log;
	fs_log.open(logfilename,fstream::out | fstream::trunc);
	fs_log.close();
	
	
	//Penetration rate as second variable
	if (argc>=2)	{		sscanf(argv[1],"%d",&UDP_PORT);}
	
	if (argc>=3)	{		sscanf(argv[2],"%f",&penetration);}   
	
	if (argc>=4)	{		sscanf(argv[3],"%d",&delay_type);} 
	

	
	get_ip_address();           // READ the ASC controller IP address into INTip from "ntcipIP.txt"
	
	get_configfile();
	
	
	//Get number of lanes each phase
	get_lane_no();
	cout<<"Number of lanes of each phase is:";
	cout<<LaneNo[0]<<" "<<LaneNo[1]<<" "<<LaneNo[2]<<" "<<LaneNo[3]<<" "<<LaneNo[4]<<" "<<LaneNo[5]<<" "<<LaneNo[6]<<" "<<LaneNo[7]<<endl;
	
	
	//-----------------Read in the ConfigIS Every time in case of changing plan-----------------------//
    int curPlan=CurTimingPlanRead();
    sprintf(temp_log,"Current timing plan is:\t%d\n",curPlan);    //cout<<temp_log;
    outputlog(temp_log);

    //PhaseTimingStatusRead();  // Find the disabled phases.

    IntersectionConfigRead(curPlan,ConfigFile);  // Generate: configinfo_XX.txt
    IntersectionPedConfigRead(curPlan,ConfigFile);   //Read configured ped walking time and clearance time
    
    //Read Signal Parameters for traffic control to phase_seq, MinGreen, MaxGreen, Yellow and Red
    ReadSignalParameters(Signal_Configure_COP_File);
    sprintf(temp_log,"Phase Sequence: %d %d %d %d %d %d %d %d\n",phase_seq[0],phase_seq[1],phase_seq[2],phase_seq[3],phase_seq[4],phase_seq[5],phase_seq[6],phase_seq[7]);
    outputlog(temp_log);cout<<temp_log;
    sprintf(temp_log,"Min Green Time: %d %d %d %d %d %d %d %d\n",MinGreen[0],MinGreen[1],MinGreen[2],MinGreen[3],MinGreen[4],MinGreen[5],MinGreen[6],MinGreen[7]);
    outputlog(temp_log);cout<<temp_log;
    sprintf(temp_log,"Yellow Time: %d %d %d %d %d %d %d %d\n",Yellow[0],Yellow[1],Yellow[2],Yellow[3],Yellow[4],Yellow[5],Yellow[6],Yellow[7]);
    outputlog(temp_log);cout<<temp_log;
    sprintf(temp_log,"Red Time: %d %d %d %d %d %d %d %d\n",Red[0],Red[1],Red[2],Red[3],Red[4],Red[5],Red[6],Red[7]);
    outputlog(temp_log);cout<<temp_log;
    sprintf(temp_log,"Max Green Time: %d %d %d %d %d %d %d %d\n",MaxGreen[0],MaxGreen[1],MaxGreen[2],MaxGreen[3],MaxGreen[4],MaxGreen[5],MaxGreen[6],MaxGreen[7]);
    outputlog(temp_log);cout<<temp_log;
    sprintf(temp_log,"Ped Walk Time: %d %d %d %d %d %d %d %d\n",PedWalk[0],PedWalk[1],PedWalk[2],PedWalk[3],PedWalk[4],PedWalk[5],PedWalk[6],PedWalk[7]);
    outputlog(temp_log);cout<<temp_log;
    sprintf(temp_log,"Ped Clr Time: %d %d %d %d %d %d %d %d\n",PedClr[0],PedClr[1],PedClr[2],PedClr[3],PedClr[4],PedClr[5],PedClr[6],PedClr[7]);
    outputlog(temp_log);cout<<temp_log;
    
    
    PrintPlan2Log(ConfigFile);
    ReadInConfig(ConfigFile); // Find the missing phases of the signal table, save to ConfigIS
    PrintRSUConfig();
	
	
	
	int i,j,k;
	for(i=4;i>0;i--) //warm up...
    {
        PhaseTimingStatusRead();
        Phases.UpdatePhase(phase_read);
        Phases.Display();
        //Phases.RecordPhase(signal_plan_file);
        msleep(1000);
    }
	Phases.PrePhase[0]=0;
	Phases.PrePhase[1]=0;
	
	previous_phase[0]=0;
	previous_phase[1]=0;
	

	//int rolling_horizon;  //every 7 seconds, solve COP
	int begintime;
	

	int control_timer;
	//double phase_read_time=GetSeconds();   //time clock for reading phase status
	
	int control_flag=0;  //used to switch between solving COP and control the signal
	//int skip_phase_sum;
	int conflit_flag=0;  //Whether there is a vehicle coming from the conflict phase
	
	//Record current red elapse time information
	//Notes: since COP always runs at the beginning of the green time (2 phases), actually we should calculate the duration of previous red phase for the queue length estimation
	//for the 2 phases just turned red, the red duration time could be 0 (or in actually calculation they are very small)
	//for other four phases, just in the middle of red duration
	
	double red_start_time[8];
	int previous_signal_color[8];
	//initialize red start time
	for(i=0;i<8;i++)
	{
		previous_signal_color[i]=phase_read.phaseColor[i];
		if(phase_read.phaseColor[i]==1)
			red_start_time[i]=GetSeconds();
		else
			red_start_time[i]=0;
	}
	
	
	
	//------------init: Begin of Network connection------------------------------------
	int sockfd;

	struct sockaddr_in sendaddr;
	struct sockaddr_in recvaddr;
	int numbytes, addr_len;
	int broadcast=1;

	if((sockfd = socket(AF_INET,SOCK_DGRAM,0)) == -1)
	{
		perror("sockfd");
		exit(1);
	}

	if((setsockopt(sockfd,SOL_SOCKET,SO_BROADCAST,
		&broadcast,sizeof broadcast)) == -1)
	{
		perror("setsockopt - SO_SOCKET ");
		exit(1);
	}
     
	sendaddr.sin_family = AF_INET;
	sendaddr.sin_port = htons(33333);  //*** IMPORTANT: the trajectory pushing code should also have this port. ***//
	sendaddr.sin_addr.s_addr = INADDR_ANY;//inet_addr(OBU_ADDR);//INADDR_ANY;

	memset(sendaddr.sin_zero,'\0',sizeof sendaddr.sin_zero);

	if(bind(sockfd, (struct sockaddr*) &sendaddr, sizeof sendaddr) == -1)
	{
		perror("bind");        exit(1);
	}

	recvaddr.sin_family = AF_INET;
	recvaddr.sin_port = htons(UDP_PORT);
	recvaddr.sin_addr.s_addr = inet_addr("127.0.0.1") ; //local host;
	memset(recvaddr.sin_zero,'\0',sizeof recvaddr.sin_zero);

	int addr_length = sizeof ( recvaddr );
	int recv_data_len;
	//-----------------------End of Network Connection------------------//
	
	int check_time_point=99999; //this is the time point (at the time point left turn green turns to yellow) to check the ped signal state;
								//only applies to leading left turn, when ped button is pushed when left turn is on
								
	int Ped_Status=0;   //Whether there is a ped call or ped phase is on  0: on call and all phase is off 1: yes
	int solving_timer= 0;
	
	while (true)
	{	
	
	currenttime=time(NULL);
	//int difference=currenttime-begintime;
	
	//sprintf(temp_log,"The Difference is %d\n",difference);
	//outputlog(temp_log); cout<<temp_log;
	
	
	//read signal phase status every 2 seconds and calculate previous phase
	//double temp_time=GetSeconds();
	//if (temp_time-phase_read_time>2)
	//{
		//phase_read_time=temp_time;  //reset phase_read_time
		PhaseTimingStatusRead();
		Phases.UpdatePhase(phase_read);
		
		for(int i=0;i<2;i++)
		{
			InitPhase[i]=Phases.InitPhase[i]+1;   //{1-8}
			InitTime[i] =Phases.InitTime[i];      // ALSO is the (Yellow+Red) Left for the counting down time ***Important***
			GrnElapse[i]=Phases.GrnElapse[i];     // If in Green
			CurrPhase[i]=Phases.CurPhase[i]+1;      // if in yellow or red, current phase will be different from Initphase
		}
		
		int conflict=Checkconflict(CurrPhase);
		
		if(conflict==1)   //phase confliction
		{
			cout<<"Phase conflict!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
			ModifyCurPhase(CurrPhase,phase_seq);
			
			cout<<"Current phase is: "<<CurrPhase[0]<<" "<<CurrPhase[1]<<endl;
		}
		
		conflict=Checkconflict(CurrPhase);
		if(conflict==1)   //phase confliction again
		{
			cout<<"Phase conflict again!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
			CurrPhase[0]=InitPhase[0];
			CurrPhase[1]=InitPhase[1];
		}
		
		
	

	
	//Calculate red elapse time for each phase, if the signal turns to green, keep the previous red duration until turns to red again
	for(i=0;i<8;i++)
	{
		if (previous_signal_color[i]!=1 && phase_read.phaseColor[i]==1)  //signal changed from other to red
		{
			red_start_time[i]=GetSeconds();
		}		
		if (phase_read.phaseColor[i]==1)
		{
			red_elapse_time[i]=GetSeconds()-red_start_time[i];
		}
		previous_signal_color[i]=phase_read.phaseColor[i];
	}
	
	//sprintf(temp_log,"phase_read is: %d %d %d %d %d %d %d %d \n",phase_read.phaseColor[0],phase_read.phaseColor[1],phase_read.phaseColor[2],phase_read.phaseColor[3],phase_read.phaseColor[4],phase_read.phaseColor[5],phase_read.phaseColor[6],phase_read.phaseColor[7]);
	//outputlog(temp_log);
	//sprintf(temp_log,"The red elapse time for each phase is:\n");
	//outputlog(temp_log);
	//sprintf(temp_log,"%f %f %f %f %f %f %f %f \n",red_elapse_time[0],red_elapse_time[1],red_elapse_time[2],red_elapse_time[3],red_elapse_time[4],red_elapse_time[5],red_elapse_time[6],red_elapse_time[7]);
	//outputlog(temp_log);

	//print out the signal timing data
	//fstream sig;
	//sig.open(SignalTimingData,ios::out|ios::app);	
	//sig<<fixed<<setprecision(2)<<GetSeconds()<<" ";					
	//sig<<phase_read.phaseColor[0]<<" "<<phase_read.phaseColor[1]<<" "<<phase_read.phaseColor[2]<<" "<<phase_read.phaseColor[3]<<" "<<phase_read.phaseColor[4]<<" "<<phase_read.phaseColor[5]<<" "<<phase_read.phaseColor[6]<<" "<<phase_read.phaseColor[7]<<endl;
	//sig.close();
	
	
	//Calculate previous phases
	if(Phases.CurPhase[0]!=Phases.PrePhase[0])
	{
		previous_phase[0]=Phases.PrePhase[0]+1;
		Phases.PrePhase[0]=Phases.CurPhase[0];
	}
	
	if(Phases.CurPhase[1]!=Phases.PrePhase[1])
	{
		previous_phase[1]=Phases.PrePhase[1]+1;
		Phases.PrePhase[1]=Phases.CurPhase[1];
	}
	
	//cout<<"CurrPhase is "<<Phases.CurPhase[0]+1<<" "<<Phases.CurPhase[1]+1<<endl;
	//cout<<"PrevPhase is "<<previous_phase[0]<<" "<<previous_phase[1]<<endl;
		
	
	
	if (control_flag==0)  //solving COP
	{	cout<<"Back to COP"<<endl;
		//reset begintime;
		//begintime=currenttime;
		//read arrival table from file
				
		               
		//Update to get the current signal status
		//PhaseTimingStatusRead();
		//Phases.UpdatePhase(phase_read);	
		//for(int i=0;i<2;i++)
		//{
		//	InitPhase[i]=Phases.InitPhase[i]+1;   //{1-8}
		//	InitTime[i] =Phases.InitTime[i];      // ALSO is the (Yellow+Red) Left for the counting down time ***Important***
	//		GrnElapse[i]=Phases.GrnElapse[i];     // If in Green
	//		CurrPhase[i]=Phases.CurPhase[i]+1;      // if in yellow or red, current phase will be different from Initphase
	//	}
				
	

	//COP starts here!!!!!!!!!!!!!!!!
	//Case 1: if the current signal status is yellow or red, wait until yellow or red ends
	if (InitTime[0]!=0 && InitTime[1]!=0)
	{
		//begintime=(int)currenttime-rolling_horizon+ceil(InitTime[0]);
		sprintf(temp_log,"Yellow/Red interval, wait until %f to apply COP\n",InitTime[0]);
		outputlog(temp_log); cout<<temp_log;
	}
	//Case 2: if the current signal status is green, apply COP from the current phase
	if (GrnElapse[0]!=0 || GrnElapse[1]!=0)
	{
	    //if (GrnElapse[0]>=ConfigIS.Gmin[InitPhase[0]-1]-6 || GrnElapse[1]>=ConfigIS.Gmin[InitPhase[1]-1]-6)   //already passed min green time -6		
	    
		if (GrnElapse[0]>0 || GrnElapse[1]>0)   //green already start		
		{
			//request for trajectory data
			char buf[64]="Request Trajectory from signal control";
			
			cout<<"Sent Request!"<<endl;
			
			//send request
			recvaddr.sin_port = htons(UDP_PORT);
			int numbytes = sendto(sockfd,buf,sizeof(buf) , 0,(struct sockaddr *)&recvaddr, addr_length);
		
			recv_data_len = recvfrom(sockfd, buf_traj, sizeof(buf_traj), 0,
							(struct sockaddr *)&sendaddr, (socklen_t *)&addr_length);

			if(recv_data_len<0)
			{
				printf("Receive Request failed\n");

				continue;
			}
			
			sprintf(temp_log,"Received Trajectory Data!\n");
			outputlog(temp_log); cout<<temp_log;
			
			trackedveh.ClearList(); //clear the list for new set of data
			
			//unpack the trajectory data and save to trackedveh list
			UnpackTrajData1(buf_traj);
			
			sprintf(temp_log,"The Number of Vehicle Received is: %d\n",trackedveh.ListSize());
			outputlog(temp_log); cout<<temp_log;
			
			//test output of the trajectory data
			//~ trackedveh.Reset();
			//~ for(i=0;i<trackedveh.ListSize();i++)
			//~ {
			//~ sprintf(temp_log,"%d %lf %lf %lf %d %d %d %lf\n",trackedveh.Data().TempID,trackedveh.Data().Speed,trackedveh.Data().stopBarDistance,trackedveh.Data().acceleration,trackedveh.Data().approach,trackedveh.Data().lane,trackedveh.Data().req_phase,trackedveh.Data().time_stop);
			//~ outputlog(temp_log); //cout<<temp_log;
			//~ trackedveh.Next();
			//~ }
			//output of the signal data
			sprintf(temp_log,"phase_read is: %d %d %d %d %d %d %d %d \n",phase_read.phaseColor[0],phase_read.phaseColor[1],phase_read.phaseColor[2],phase_read.phaseColor[3],phase_read.phaseColor[4],phase_read.phaseColor[5],phase_read.phaseColor[6],phase_read.phaseColor[7]);
			outputlog(temp_log);
			sprintf(temp_log,"The red elapse time for each phase is:\n");
			outputlog(temp_log);
			sprintf(temp_log,"%f %f %f %f %f %f %f %f \n",red_elapse_time[0],red_elapse_time[1],red_elapse_time[2],red_elapse_time[3],red_elapse_time[4],red_elapse_time[5],red_elapse_time[6],red_elapse_time[7]);
			outputlog(temp_log);
			double cur_time=GetSeconds();
			sprintf(temp_log,"Current time is: %f \n",cur_time);
			outputlog(temp_log);
			
			
			
			//clear current arrival table
			for (i=0;i<131;i++)
				for(j=0;j<8;j++)
				{
					ArrivalTable[i][j]=0;
				}
			
		    	   
			if (penetration>=0.95)   //construct arrival table directly
			{
				trackedveh.Reset();
				while(!trackedveh.EndOfList())  
					{
						if (trackedveh.Data().req_phase>0) //Requested phase  
						{
							if(trackedveh.Data().Speed>1)
							{
								int ETA= ceil(trackedveh.Data().stopBarDistance/trackedveh.Data().Speed);
								if (ETA<50)
									ArrivalTable[ETA][trackedveh.Data().req_phase-1]++;
							}
							else
								ArrivalTable[0][trackedveh.Data().req_phase-1]++;
							
						}
					trackedveh.Next();
					}
			}
			else
			{      
				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				//Algorithm to infer vehicle location and speed based on sample vehicle data and create arrival table
				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				cout<<"Estimating Location and Position of Unequipped Vehicle:"<<endl;
				
				for (i=0;i<8;i++)  
				{	
				
					//Assign vehicles of each phase to the vehlist_each_phase
					trackedveh.Reset();
					vehlist_each_phase.ClearList();
					while(!trackedveh.EndOfList())  
					{
						if (trackedveh.Data().req_phase==i+1)  //assign to the same phase
						{
							temp_veh=trackedveh.Data();
							vehlist_each_phase.InsertRear(temp_veh);
						}
					trackedveh.Next();
					}
				
					
					sprintf(temp_log,"Phase: %d\n",i+1);
					outputlog(temp_log); cout<<temp_log;
					
					//sprintf(temp_log,"The input list is:\n");
					//outputlog(temp_log); cout<<temp_log;
					vehlist_each_phase.Reset();
					for(j=0;j<vehlist_each_phase.ListSize();j++)
					{
					sprintf(temp_log,"%d %lf %lf %lf %d %d %d %lf\n",vehlist_each_phase.Data().TempID,vehlist_each_phase.Data().Speed,vehlist_each_phase.Data().stopBarDistance,vehlist_each_phase.Data().acceleration,vehlist_each_phase.Data().approach,vehlist_each_phase.Data().lane,vehlist_each_phase.Data().req_phase,vehlist_each_phase.Data().time_stop);
					outputlog(temp_log); //cout<<temp_log;
					vehlist_each_phase.Next();
					}
					
					cout<<"The number of lanes is "<<LaneNo[i]<<endl;
					
					if (vehlist_each_phase.ListSize()!=0)  //There is vehicle in the list 
						EVLS(i+1, cur_time, red_elapse_time[i], LaneNo[i]);
				}
			}
			
			
			
			
			//read arrival table from file
			/*
			fstream fs;
			fs.open(arrivaltablefile,ios::in);
			string line;
			for(i=0;i<131;i++)
			{
				getline(fs,line);
				//sprintf(temp_log,line.c_str());
				//outputlog(temp_log);
				sscanf(line.c_str(),"%d %d %d %d %d %d %d %d",&ArrivalTable[i][0],&ArrivalTable[i][1],&ArrivalTable[i][2],&ArrivalTable[i][3],&ArrivalTable[i][4],&ArrivalTable[i][5],&ArrivalTable[i][6],&ArrivalTable[i][7]);
			}
			fs.close();
			
			*/
				
			//calculate skipped phase based on ELVS
			int temp_arr=0;
			for(i=0;i<8;i++)
			{
				for(j=0;j<131;j++)
				{
					temp_arr+=ArrivalTable[j][i];
				}
				if (temp_arr==0 && i+1!=CurrPhase[0] && i+1!=CurrPhase[1])    //make sure the current phase is not skipped, added by YF: 12/08/2014
					skip_phase[i]=0;  //skip the phase
				else
					skip_phase[i]=1;   //don't skip the phase
				temp_arr=0;
			}
			
			
			//Check skip phase's detector and see whether they have calls (useful for left turn phases under low penetration rate)
			DetRead();
			
			sprintf(temp_log,"Detector Occupancy: %d %d %d %d %d %d %d %d \n",occupancy[0],occupancy[1],occupancy[2],occupancy[3],occupancy[4],occupancy[5],occupancy[6],occupancy[7]);
			outputlog(temp_log); cout<<temp_log;
			
			for (i=0;i<8;i++)  
			{
				if (skip_phase[i]==0 && occupancy[i]>0)   //no demand from connected vehicle, but the detector is occupied
				{
					skip_phase[i]=1;        //Do not skip phase
					ArrivalTable[0][i]=1;  //Add one vehicle to the arrival table at queue
					cout<<"No connected vehicle data but vehicle present at the detector for phase "<<i+1<<endl;
				}
			}
			
			//Complete the barrier by adding missing phases (if the phase is not in use)
			Complete_Barrier();
			
			
			//print the arrival table in the log  (only the first 30 rows)
			for (i=0;i<30;i++)
			{
				sprintf(temp_log,"%d %d %d %d %d %d %d %d \n",ArrivalTable[i][0],ArrivalTable[i][1],ArrivalTable[i][2],ArrivalTable[i][3],ArrivalTable[i][4],ArrivalTable[i][5],ArrivalTable[i][6],ArrivalTable[i][7]);
				outputlog(temp_log);
			}
          			
			sprintf(temp_log,"phase_read is: %d %d %d %d %d %d %d %d \n",phase_read.phaseColor[0],phase_read.phaseColor[1],phase_read.phaseColor[2],phase_read.phaseColor[3],phase_read.phaseColor[4],phase_read.phaseColor[5],phase_read.phaseColor[6],phase_read.phaseColor[7]);
			outputlog(temp_log); cout<<temp_log;
			sprintf(temp_log,"Initphase is %d %d; InitTime is %f %f; Grnelapse is %f %f; CurPhase is %d %d\n",InitPhase[0],InitPhase[1],InitTime[0],InitTime[1],GrnElapse[0],GrnElapse[1],CurrPhase[0],CurrPhase[1]);
			outputlog(temp_log); cout<<temp_log;
			sprintf(temp_log,"previous phase is %d %d\n",previous_phase[0],previous_phase[1]);
			outputlog(temp_log); cout<<temp_log;
	    		
			//find the passed phase in the same barrier
			Find_Passed_Phase_In_Same_Barrier(previous_phase,CurrPhase);
			
			//passed_phase[0]=0;
			//passed_phase[1]=0;
			
			//////////////////////////////////////////////////////////////////
		
			sprintf(temp_log,"Green interval, start COP: \n");
			outputlog(temp_log); cout<<temp_log;
			
			sprintf(temp_log,"The Passed phases are %d %d\n",passed_phase[0],passed_phase[1]);
			outputlog(temp_log); cout<<temp_log;
			
			sprintf(temp_log,"The skipped phases are %d %d %d %d %d %d %d %d\n",skip_phase[0],skip_phase[1],skip_phase[2],skip_phase[3],skip_phase[4],skip_phase[5],skip_phase[6],skip_phase[7]);
			outputlog(temp_log); cout<<temp_log;
			
			//skip_phase_sum=0;  //total number of skip phases
			//for(i=0;i<8;i++)
			//{
			//	skip_phase_sum+=skip_phase[i];
			//}
	          		
			conflit_flag=Conflit_call(CurrPhase,skip_phase);
			
			
			//Set queue warning flag
			//~ if(ArrivalTable[0][0]>=9 )  //Phase 1 have very long queue
			//~ {
				//~ queue_warning_P1=1;
				//~ sprintf(temp_log,"Queue warning!!!!!!!!!!! need to serve left turn ASAP");
				//~ outputlog(temp_log); cout<<temp_log;
			//~ }
			//~ else
				//~ queue_warning_P1=0;
				//~ 
			//~ if(ArrivalTable[0][4]>=9 )  //phase 5 have very long queue
			//~ {
				//~ queue_warning_P5=1;
				//~ sprintf(temp_log,"Queue warning!!!!!!!!!!! need to serve left turn ASAP");
				//~ outputlog(temp_log); cout<<temp_log;
			//~ }
			//~ else
				//~ queue_warning_P5=0;
			
			
			if (conflit_flag==0)    //no any vehicle arrival at conflict phase
			{
				sprintf(temp_log,"No vehicle arrival at conflict phase, Wait... \n");
				outputlog(temp_log); cout<<temp_log;
				msleep(1000);  //wait for one second and check again
			}
			else //has at least one vehicle arrival at conflict phase
			{
				double t_1,t_2; //---time stamps used to calculate the time needed for COP
				
				t_1=GetSeconds();
				
				int int_GrnElapse[2];
				//int_GrnElapse[0]= min(MinGreen[CurrPhase[0]-1],(int) GrnElapse[0]);
				//int_GrnElapse[1]= min(MinGreen[CurrPhase[1]-1],(int) GrnElapse[1]);
				
				int_GrnElapse[0]= (int) GrnElapse[0];
				int_GrnElapse[1]= (int) GrnElapse[1];
				
				
				sprintf(temp_log,"The int green elapse time is %d %d\n",int_GrnElapse[0],int_GrnElapse[1]);
				outputlog(temp_log);
				
				
				//Check Ped Call and Current Ped Phase, return which ped phases need to be considered
				Ped_Status_Read();
				Ped_Status=Check_Ped_Phase_Info();		
				
				sprintf(temp_log,"Ped_Status is: %d\n",Ped_Status);
				cout<<temp_log;outputlog(temp_log);
				
				//Before solving COP, read the signal parameters again, in case COP changes the min green and max green time
				ReadSignalParameters(Signal_Configure_COP_File);
	          			
				//run ring barrier COP algorithm
				COP_DUAL_RING(CurrPhase, int_GrnElapse, passed_phase,skip_phase);
				
				int cop_solve_time;
				
				t_2=GetSeconds();
				sprintf(temp_log,"The time for COP is: %lf second \n",t_2-t_1);
				outputlog(temp_log); cout<<temp_log;
				
				cop_solve_time=(int) t_2-t_1+1;
				
				//solving_timer=currenttime;
				
				sprintf(temp_log,"The optimal phase sequences are:\n");
				outputlog(temp_log); cout<<temp_log;
				
				sprintf(temp_log,"Ring 1: %d %d %d %d\n",opt_sig_plan[0][0], opt_sig_plan[0][1],opt_sig_plan[0][2],opt_sig_plan[0][3]);
				outputlog(temp_log); cout<<temp_log;
				sprintf(temp_log,"Ring 2: %d %d %d %d\n",opt_sig_plan[1][0], opt_sig_plan[1][1],opt_sig_plan[1][2],opt_sig_plan[1][3]);
				outputlog(temp_log); cout<<temp_log;
				
				sprintf(temp_log,"Optimal Signal Sequence is:\n");
				outputlog(temp_log); cout<<temp_log;
				sprintf(temp_log,"Ring 1: %d %d %d %d\n",opt_sig_seq[0][0], opt_sig_seq[0][1],opt_sig_seq[0][2],opt_sig_seq[0][3]);
				outputlog(temp_log); cout<<temp_log;
				sprintf(temp_log,"Ring 2: %d %d %d %d\n",opt_sig_seq[1][0], opt_sig_seq[1][1],opt_sig_seq[1][2],opt_sig_seq[1][3]);
				outputlog(temp_log); cout<<temp_log;
				
				
				//Setup the check time point
				if(opt_sig_plan[0][0]!=0 || opt_sig_plan[1][0]!=0)
					check_time_point= max(opt_sig_plan[0][0],opt_sig_plan[1][0])-cop_solve_time+2;
				else
					check_time_point=9999;


					//construct the control Eventlist
					
					Eventlist_R1.ClearList();
					Eventlist_R2.ClearList();
					Construct_eventlist(opt_sig_plan,CurrPhase);
					
					Eventlist_R1.Reset();
					while(!Eventlist_R1.EndOfList())
					{
						int temp_time=Eventlist_R1.Data().time;
						Eventlist_R1.Data().time=temp_time-cop_solve_time;  
						if (Eventlist_R1.Data().time<0)
							Eventlist_R1.Data().time=0;
						sprintf(temp_log,"Event_R1 %d %d %d\n",Eventlist_R1.Data().time,Eventlist_R1.Data().phase,Eventlist_R1.Data().action);
						outputlog(temp_log);
						Eventlist_R1.Next();
					}
					Eventlist_R2.Reset();
					while(!Eventlist_R2.EndOfList())
					{
						int temp_time=Eventlist_R2.Data().time;
						Eventlist_R2.Data().time=temp_time-cop_solve_time;
						if (Eventlist_R2.Data().time<0)
							Eventlist_R2.Data().time=0;
						sprintf(temp_log,"Event_R2 %d %d %d\n",Eventlist_R2.Data().time,Eventlist_R2.Data().phase,Eventlist_R2.Data().action);
						outputlog(temp_log);
						Eventlist_R2.Next();
					}
					
					control_flag=1;
					
			//Pack the Event_list and Send to the SignalControlInterface  Added by YF: 10/28/2014
			if(Eventlist_R1.ListSize()!=0 || Eventlist_R2.ListSize()!=0)
			{
				byte tmp_event_data[500];
				int size=0;
				Pack_Event_List(tmp_event_data, size);						
				char* event_data;
				event_data= new char[size];			
				for(i=0;i<size;i++)
				event_data[i]=tmp_event_data[i];
				//Send trajectory data
				sprintf(temp_log,"Send Signal Conotrol Event to SignalControllerInterface, The size is %d\n",size);
				outputlog(temp_log); cout<<temp_log;
				recvaddr.sin_port = htons(44444);
				sendto(sockfd,event_data,size+1 , 0,(struct sockaddr *)&recvaddr, addr_length);	
			}
							
			}
			begintime=time(NULL);
		}
		else  //still red or yellow time
		{
			//begintime=(int)currenttime-rolling_horizon+ceil(ConfigIS.Gmin[InitPhase[0]-1]-GrnElapse[0])-1;
			sprintf(temp_log,"Still within Min Green time, wait until %f to apply COP\n",ConfigIS.Gmin[InitPhase[0]-1]-GrnElapse[0]-3);
			outputlog(temp_log); cout<<temp_log;
		}	
	}
	
	}	
		if(control_flag==1)
		{
			
				
				currenttime=time(NULL);
				
				
				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Changed here!!!!!!!!!!!!!!!!!!!!!!!!
				//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Soving every 5 seconds!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
				//~ if (currenttime-solving_timer>5)
				//~ {
					//~ solving_timer=currenttime;
					//~ control_flag=0;
					//~ cout<<"5 seconds passed, solve again!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"<<endl;
				//~ }
				
				//Check ped call after the left turn phase
				if(currenttime-begintime>check_time_point)
				{
					sprintf(temp_log,"Reach Check point!!\n");
					cout<<temp_log;outputlog(temp_log);
					Ped_Status_Read();
					int Current_Ped_Status=Check_Ped_Phase_Info();
					if(Ped_Status==0 && Current_Ped_Status==1)  //previous no ped phase required, but current is
					{
						
						sprintf(temp_log,"Ped Status Changed during Left Turn Geeen, need to replan!!!\n");
						cout<<temp_log;outputlog(temp_log);
						control_flag=0;    //need to replan to include the ped request
					}
					else
						check_time_point=9999;
				}
				
				
				if(Eventlist_R1.ListSize()==0 && Eventlist_R2.ListSize()==0)
				{
					if(currenttime-begintime>2)
						control_flag=0;
				}
				else
				{
					Eventlist_R1.Reset(Eventlist_R1.ListSize()-1);
					Eventlist_R2.Reset(Eventlist_R2.ListSize()-1);
					if(currenttime-begintime>Eventlist_R1.Data().time+2 || currenttime-begintime>Eventlist_R2.Data().time+2)  //already reach the end of the barrier, back to COP
					{
						Eventlist_R1.ClearList();
						Eventlist_R2.ClearList();
						sprintf(temp_log,"End of Planning time, back to COP at time %ld\n",currenttime);
						outputlog(temp_log);cout<<temp_log;
						control_flag=0;
					}
				}
			
		}		
	msleep(200);
      	
	}// End of while(true)
	//*/
	return 0;

} // ---End of main()

//**********************************************************************************//

int outputlog(char *output)
{
	FILE * stream = fopen( logfilename, "r" );

	if (stream==NULL)
	{
		perror ("Error opening file");
	}

	fseek( stream, 0L, SEEK_END );
	long endPos = ftell( stream );
	fclose( stream );

	fstream fs;
	if (endPos <10000000)
		fs.open(logfilename, ios::out | ios::app);
	else
		fs.open(logfilename, ios::out | ios::trunc);

	//fstream fs;
	//fs.open("/nojournal/bin/OBU_logfile.txt", ios::out | ios::app);
	if (!fs || !fs.good())
	{
		cout << "could not open file!\n";
		return -1;
	}
	fs << output;

	if (fs.fail())
	{
		cout << "failed to append to file!\n";
		return -1;
	}
	fs.close();

	return 1;
}



int COP_Intersectioncontrol(int CurrPhase[2], int planed_phases, int opt_timing[12])
{
	int i;
	int CMD_Total;
	int phase_in_seq;  // phase sequence of ring 1
	//only simple case first: run schedule for one phase
	//sprintf(temp_log,"opt_timing[0]= %d \n",opt_timing[0]);
	//outputlog(temp_log); cout<<temp_log;
	
	//prepare for the next phase: because phase OMIT need to be done before force off
	int temp_phase=CurrPhase[0];
	phase_in_seq=temp_phase;
	
	//sprintf(temp_log,"temp_phase is %d and phase_in_seq is %d\n",phase_in_seq,temp_phase);
	//outputlog(temp_log); cout<<temp_log;
	for(i=1;i<planed_phases;i++)  
	{
		//phase_in_seq=(CurrPhase[0]+i)%5;
		phase_in_seq++;
		phase_in_seq=phase_in_seq%5;
		if (phase_in_seq==0)
		{
			phase_in_seq++;
		}
		if (opt_timing[i]==0)  //omit unnecessary phases
		{
			CMD_Total=(int) pow(2.0,(phase_in_seq-1)*1.0); //ring 1
			CMD_Total+=(int) pow(2.0,(phase_in_seq+4-1)*1.0);  //ring 2
			IntersectionPhaseControl(PHASE_OMIT,CMD_Total,'Y');
			sprintf(temp_log,"PHASE_OMIT Phase %d and %d with CMD %d at time %d\n",phase_in_seq,phase_in_seq+4,CMD_Total,currenttime);
			outputlog(temp_log); cout<<temp_log;
		}
		else 
		{			
			break;
		}
	}
	
	//deal with the current phase
	if (opt_timing[0]==0)  // the current phase will be terminated immediately
	{ 
		//outputlog("I'm here \n");
		CMD_Total=(int) pow(2.0,(CurrPhase[0]-1)*1.0); //ring 1
		CMD_Total+=(int) pow(2.0,(CurrPhase[0]+4-1)*1.0);  //ring 2
		IntersectionPhaseControl(PHASE_FORCEOFF,CMD_Total,'Y');
		sprintf(temp_log,"FORCE_OFF Phase %d and %d with CMD %d at time %d\n",CurrPhase[0],CurrPhase[0]+4,CMD_Total,currenttime);
		outputlog(temp_log); cout<<temp_log;
		
	}
	else   //the current phase will be hold
	{
		if (currenttime<hold_timer)
		{
			CMD_Total=(int) pow(2.0,(CurrPhase[0]-1)*1.0); //ring 1
			CMD_Total+=(int) pow(2.0,(CurrPhase[0]+4-1)*1.0);  //ring 2
			IntersectionPhaseControl(PHASE_HOLD,CMD_Total,'Y');
			sprintf(temp_log,"PHASE_HOLD Phase %d and %d with CMD %d at time %d\n",CurrPhase[0],CurrPhase[0]+4,CMD_Total,currenttime);
			outputlog(temp_log); cout<<temp_log;
		}
		else  //hold time is over
		{
			CMD_Total=(int) pow(2.0,(CurrPhase[0]-1)*1.0); //ring 1
			CMD_Total+=(int) pow(2.0,(CurrPhase[0]+4-1)*1.0);  //ring 2
			IntersectionPhaseControl(PHASE_FORCEOFF,CMD_Total,'Y');
			sprintf(temp_log,"PHASE_FORCEOFF Phase %d and %d after hold with CMD %d at time %d\n",CurrPhase[0],CurrPhase[0]+4,CMD_Total,currenttime);
			outputlog(temp_log); cout<<temp_log;
		}
	}
	   
	//vehicle call should be placed after hold
	phase_in_seq=temp_phase;
	//sprintf(temp_log,"temp_phase is %d and phase_in_seq is %d\n",phase_in_seq,temp_phase);
	//outputlog(temp_log); cout<<temp_log;
	for(i=1;i<planed_phases;i++)  
	{
		//phase_in_seq=(CurrPhase[0]+i)%5;
		phase_in_seq++;
		phase_in_seq=phase_in_seq%5;
		if (phase_in_seq==0)
		{
			phase_in_seq++;
		}
		if (opt_timing[i]!=0)  //call the next phases
		{
			CMD_Total=(int) pow(2.0,(phase_in_seq-1)*1.0); //ring 1
			CMD_Total+=(int) pow(2.0,(phase_in_seq+4-1)*1.0);  //ring 2
			IntersectionPhaseControl(PHASE_VEH_CALL,CMD_Total,'Y');
			sprintf(temp_log,"PHASE_VEH_CALL Phase %d and %d with CMD %d at time %d\n",phase_in_seq,phase_in_seq+4,CMD_Total,currenttime);
			outputlog(temp_log); cout<<temp_log;
			break;
		}

	}
	
}

int Find_Passed_Phase_In_Same_Barrier(int pre_phase[2], int cur_phase[2])
{
	//default: no passed phase
	passed_phase[0]=0;
	passed_phase[1]=0;
	for (int i=0;i<2;i++)  //2 rings
	{
		if (pre_phase[i]==1+i*4 && cur_phase[i]==2+i*4)
		passed_phase[i]=1+i*4;
		if (pre_phase[i]==2+i*4 && cur_phase[i]==1+i*4)
		passed_phase[i]=2+i*4;
		if (pre_phase[i]==3+i*4 && cur_phase[i]==4+i*4)
		passed_phase[i]=3+i*4;
		if (pre_phase[i]==4+i*4 && cur_phase[i]==3+i*4)
		passed_phase[i]=4+i*4;
		
	//	if(passed_phase[i]!=0)
	//	passed_phase[i]++;   //changed to phase number [1-8]
	}
	
}
  
int Construct_eventlist(int opt_sig_plan[2][4], int cur_phase[2])
{
	Schedule Temp_event;
		
	
	if(cur_phase[0]==1)
	{
		if(opt_sig_plan[0][1]!=0)  
		{
			//hold phase 1
			Temp_event.time=opt_sig_plan[0][0];
			Temp_event.phase=1;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);		
			//call phase 2
			Temp_event.time=opt_sig_plan[0][0];
			Temp_event.phase=2;
			Temp_event.action=PHASE_VEH_CALL;
			Eventlist_R1.InsertRear(Temp_event);
			//force off phase 1
			Temp_event.time=opt_sig_plan[0][0];
			Temp_event.phase=1;
			Temp_event.action=PHASE_FORCEOFF;
			Eventlist_R1.InsertRear(Temp_event);	
			//hold phase 2
			Temp_event.time=opt_sig_plan[0][0]+Yellow[0]+Red[0]+opt_sig_plan[0][1];
			Temp_event.phase=2;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			if(opt_sig_plan[0][2]!=0 || opt_sig_plan[0][3]!=0)
			{

				//call phase in next barrier: 3 or 4
				Temp_event.time=opt_sig_plan[0][0]+Yellow[0]+Red[0]+opt_sig_plan[0][1];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]!=0)  //call the first phase in sequence
					Temp_event.phase=opt_sig_seq[0][2];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]==0)
					Temp_event.phase=3;
				if (opt_sig_plan[0][2]==0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=4;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R1.InsertRear(Temp_event);	
				
				//force off phase 2
				Temp_event.time=opt_sig_plan[0][0]+Yellow[0]+Red[0]+opt_sig_plan[0][1];
				Temp_event.phase=2;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R1.InsertRear(Temp_event);

			}
		}
		else
		{
			//hold phase 1
			Temp_event.time=opt_sig_plan[0][0];
			Temp_event.phase=1;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			if(opt_sig_plan[0][2]!=0 || opt_sig_plan[0][3]!=0)
			{
				//call phase in next barrier: 3 or 4
				Temp_event.time=opt_sig_plan[0][0];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]!=0)  //call the first phase in sequence
					Temp_event.phase=opt_sig_seq[0][2];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]==0)
					Temp_event.phase=3;
				if (opt_sig_plan[0][2]==0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=4;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R1.InsertRear(Temp_event);
				//force off phase 1
				Temp_event.time=opt_sig_plan[0][0];
				Temp_event.phase=1;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R1.InsertRear(Temp_event);
			}
		}
	}
	
	if(cur_phase[0]==2)
	{
		if(opt_sig_plan[0][0]!=0)  
		{
			//hold phase 2
			Temp_event.time=opt_sig_plan[0][1];
			Temp_event.phase=2;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			//call phase 1
			Temp_event.time=opt_sig_plan[0][1];
			Temp_event.phase=1;
			Temp_event.action=PHASE_VEH_CALL;
			Eventlist_R1.InsertRear(Temp_event);
			//force off phase 2
			Temp_event.time=opt_sig_plan[0][1];
			Temp_event.phase=2;
			Temp_event.action=PHASE_FORCEOFF;
			Eventlist_R1.InsertRear(Temp_event);
			//hold phase 1
			Temp_event.time=opt_sig_plan[0][1]+Yellow[1]+Red[1]+opt_sig_plan[0][0];
			Temp_event.phase=1;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			if(opt_sig_plan[0][2]!=0 || opt_sig_plan[0][3]!=0)
			{	
				//call phase in next barrier: 3 or 4
				Temp_event.time=opt_sig_plan[0][1]+Yellow[1]+Red[1]+opt_sig_plan[0][0];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]!=0)  //call the first phase in sequence
					Temp_event.phase=opt_sig_seq[0][2];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]==0)
					Temp_event.phase=3;
				if (opt_sig_plan[0][2]==0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=4;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R1.InsertRear(Temp_event);	
				//force off phase 1
				Temp_event.time=opt_sig_plan[0][1]+Yellow[1]+Red[1]+opt_sig_plan[0][0];
				Temp_event.phase=1;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R1.InsertRear(Temp_event);
			}
		}
		else
		{
			//hold phase 2
			Temp_event.time=opt_sig_plan[0][1];
			Temp_event.phase=2;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			if(opt_sig_plan[0][2]!=0 || opt_sig_plan[0][3]!=0)
			{
				//call phase in next barrier: 3 or 4
				Temp_event.time=opt_sig_plan[0][1];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]!=0)  //call the first phase in sequence
					Temp_event.phase=opt_sig_seq[0][2];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]==0)
					Temp_event.phase=3;
				if (opt_sig_plan[0][2]==0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=4;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R1.InsertRear(Temp_event);
				//force off phase 2
				Temp_event.time=opt_sig_plan[0][1];
				Temp_event.phase=2;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R1.InsertRear(Temp_event);
			}
		}
	}
	
	if(cur_phase[0]==3)
	{
		if(opt_sig_plan[0][1]!=0)  
		{
			//hold phase 3
			Temp_event.time=opt_sig_plan[0][0];
			Temp_event.phase=3;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);			
			//call phase 4
			Temp_event.time=opt_sig_plan[0][0];
			Temp_event.phase=4;
			Temp_event.action=PHASE_VEH_CALL;
			Eventlist_R1.InsertRear(Temp_event);
			//force off phase 3
			Temp_event.time=opt_sig_plan[0][0];
			Temp_event.phase=3;
			Temp_event.action=PHASE_FORCEOFF;
			Eventlist_R1.InsertRear(Temp_event);
			//hold phase 4
			Temp_event.time=opt_sig_plan[0][0]+Yellow[2]+Red[2]+opt_sig_plan[0][1];
			Temp_event.phase=4;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			if(opt_sig_plan[0][2]!=0 || opt_sig_plan[0][3]!=0)
			{
				//call phase in next barrier: 1 or 2
				Temp_event.time=opt_sig_plan[0][0]+Yellow[2]+Red[2]+opt_sig_plan[0][1];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=opt_sig_seq[0][2];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]==0)
					Temp_event.phase=1;
				if (opt_sig_plan[0][2]==0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=2;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R1.InsertRear(Temp_event);	
				//force off phase 4
				Temp_event.time=opt_sig_plan[0][0]+Yellow[2]+Red[2]+opt_sig_plan[0][1];
				Temp_event.phase=4;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R1.InsertRear(Temp_event);
			}
		}
		else
		{
			//hold phase 3
			Temp_event.time=opt_sig_plan[0][0];
			Temp_event.phase=3;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			if(opt_sig_plan[0][2]!=0 || opt_sig_plan[0][3]!=0)
			{
				//call phase in next barrier: 1 or 2
				Temp_event.time=opt_sig_plan[0][0];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=opt_sig_seq[0][2];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]==0)
					Temp_event.phase=1;
				if (opt_sig_plan[0][2]==0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=2;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R1.InsertRear(Temp_event);
				//force off phase 3
				Temp_event.time=opt_sig_plan[0][0];
				Temp_event.phase=3;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R1.InsertRear(Temp_event);
			}
		}
	}
	
	if(cur_phase[0]==4)
	{
		if(opt_sig_plan[0][0]!=0)  
		{
			//hold phase 4
			Temp_event.time=opt_sig_plan[0][1];
			Temp_event.phase=4;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			//call phase 3
			Temp_event.time=opt_sig_plan[0][1];
			Temp_event.phase=3;
			Temp_event.action=PHASE_VEH_CALL;
			Eventlist_R1.InsertRear(Temp_event);
			//force off phase 4
			Temp_event.time=opt_sig_plan[0][1];
			Temp_event.phase=4;
			Temp_event.action=PHASE_FORCEOFF;
			Eventlist_R1.InsertRear(Temp_event);
			//hold phase 3
			Temp_event.time=opt_sig_plan[0][1]+Yellow[3]+Red[3]+opt_sig_plan[0][0];
			Temp_event.phase=3;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			if(opt_sig_plan[0][2]!=0 || opt_sig_plan[0][3]!=0)
			{
				//call phase in next barrier: 1 or 2
				Temp_event.time=opt_sig_plan[0][1]+Yellow[3]+Red[3]+opt_sig_plan[0][0];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=opt_sig_seq[0][2];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]==0)
					Temp_event.phase=1;
				if (opt_sig_plan[0][2]==0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=2;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R1.InsertRear(Temp_event);	
				//force off phase 3
				Temp_event.time=opt_sig_plan[0][1]+Yellow[3]+Red[3]+opt_sig_plan[0][0];
				Temp_event.phase=3;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R1.InsertRear(Temp_event);
			}
		}
		else
		{
			//hold phase 4
			Temp_event.time=opt_sig_plan[0][1];
			Temp_event.phase=4;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R1.InsertRear(Temp_event);
			if(opt_sig_plan[0][2]!=0 || opt_sig_plan[0][3]!=0)
			{
				//call phase in next barrier: 1 or 2
				Temp_event.time=opt_sig_plan[0][1];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=opt_sig_seq[0][2];
				if (opt_sig_plan[0][2]!=0 && opt_sig_plan[0][3]==0)
					Temp_event.phase=1;
				if (opt_sig_plan[0][2]==0 && opt_sig_plan[0][3]!=0)
					Temp_event.phase=2;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R1.InsertRear(Temp_event);
				//force off phase 4
				Temp_event.time=opt_sig_plan[0][1];
				Temp_event.phase=4;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R1.InsertRear(Temp_event);
			}
		}
	}
	
	if(cur_phase[1]==5)
	{
		if(opt_sig_plan[1][1]!=0)  
		{
			//hold phase 5
			Temp_event.time=opt_sig_plan[1][0];
			Temp_event.phase=5;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			//call phase 6
			Temp_event.time=opt_sig_plan[1][0];
			Temp_event.phase=6;
			Temp_event.action=PHASE_VEH_CALL;
			Eventlist_R2.InsertRear(Temp_event);
			//force off phase 5
			Temp_event.time=opt_sig_plan[1][0];
			Temp_event.phase=5;
			Temp_event.action=PHASE_FORCEOFF;
			Eventlist_R2.InsertRear(Temp_event);
			//hold phase 6
			Temp_event.time=opt_sig_plan[1][0]+Yellow[4]+Red[4]+opt_sig_plan[1][1];
			Temp_event.phase=6;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			if(opt_sig_plan[1][2]!=0 || opt_sig_plan[1][3]!=0)
			{
				//call phase in next barrier: 7 or 8
				Temp_event.time=opt_sig_plan[1][0]+Yellow[4]+Red[4]+opt_sig_plan[1][1];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=opt_sig_seq[1][2];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]==0)
					Temp_event.phase=7;
				if (opt_sig_plan[1][2]==0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=8;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R2.InsertRear(Temp_event);	
				//force off phase 6
				Temp_event.time=opt_sig_plan[1][0]+Yellow[4]+Red[4]+opt_sig_plan[1][1];
				Temp_event.phase=6;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R2.InsertRear(Temp_event);
			}
		}
		else
		{
			//hold phase 5
			Temp_event.time=opt_sig_plan[1][0];
			Temp_event.phase=5;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			if(opt_sig_plan[1][2]!=0 || opt_sig_plan[1][3]!=0)
			{
				//call phase in next barrier: 7 or 8
				Temp_event.time=opt_sig_plan[1][0];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=opt_sig_seq[1][2];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]==0)
					Temp_event.phase=7;
				if (opt_sig_plan[1][2]==0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=8;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R2.InsertRear(Temp_event);
				//force off phase 5
				Temp_event.time=opt_sig_plan[1][0];
				Temp_event.phase=5;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R2.InsertRear(Temp_event);
			}
		}
	}
	
	if(cur_phase[1]==6)
	{
		if(opt_sig_plan[1][0]!=0)  
		{
			//hold phase 6
			Temp_event.time=opt_sig_plan[1][1];
			Temp_event.phase=6;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			//call phase 5
			Temp_event.time=opt_sig_plan[1][1];
			Temp_event.phase=5;
			Temp_event.action=PHASE_VEH_CALL;
			Eventlist_R2.InsertRear(Temp_event);
			//force off phase 6
			Temp_event.time=opt_sig_plan[1][1];
			Temp_event.phase=6;
			Temp_event.action=PHASE_FORCEOFF;
			Eventlist_R2.InsertRear(Temp_event);
			//hold phase 5
			Temp_event.time=opt_sig_plan[1][1]+Yellow[5]+Red[5]+opt_sig_plan[1][0];
			Temp_event.phase=5;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			if(opt_sig_plan[1][2]!=0 || opt_sig_plan[1][3]!=0)
			{
				//call phase in next barrier: 3 or 4
				Temp_event.time=opt_sig_plan[1][1]+Yellow[5]+Red[5]+opt_sig_plan[1][0];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=opt_sig_seq[1][2];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]==0)
					Temp_event.phase=7;
				if (opt_sig_plan[1][2]==0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=8;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R2.InsertRear(Temp_event);	
				//force off phase 5
				Temp_event.time=opt_sig_plan[1][1]+Yellow[5]+Red[5]+opt_sig_plan[1][0];
				Temp_event.phase=5;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R2.InsertRear(Temp_event);
			}
		}
		else
		{
			//hold phase 6
			Temp_event.time=opt_sig_plan[1][1];
			Temp_event.phase=6;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			if(opt_sig_plan[1][2]!=0 || opt_sig_plan[1][3]!=0)
			{
				//call phase in next barrier: 7 or 8
				Temp_event.time=opt_sig_plan[1][1];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=opt_sig_seq[1][2];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]==0)
					Temp_event.phase=7;
				if (opt_sig_plan[1][2]==0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=8;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R2.InsertRear(Temp_event);
				//force off phase 6
				Temp_event.time=opt_sig_plan[1][1];
				Temp_event.phase=6;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R2.InsertRear(Temp_event);
			}
		}
	}
	
	if(cur_phase[1]==7)
	{
		if(opt_sig_plan[1][1]!=0)  
		{
			//hold phase 7
			Temp_event.time=opt_sig_plan[1][0];
			Temp_event.phase=7;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			//call phase 8
			Temp_event.time=opt_sig_plan[1][0];
			Temp_event.phase=8;
			Temp_event.action=PHASE_VEH_CALL;
			Eventlist_R2.InsertRear(Temp_event);
			//force off phase 7
			Temp_event.time=opt_sig_plan[1][0];
			Temp_event.phase=7;
			Temp_event.action=PHASE_FORCEOFF;
			Eventlist_R2.InsertRear(Temp_event);
			//hold phase 8
			Temp_event.time=opt_sig_plan[1][0]+Yellow[6]+Red[6]+opt_sig_plan[1][1];
			Temp_event.phase=8;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			if(opt_sig_plan[1][2]!=0 || opt_sig_plan[1][3]!=0)
			{
				//call phase in next barrier: 5 or 6
				Temp_event.time=opt_sig_plan[1][0]+Yellow[6]+Red[6]+opt_sig_plan[1][1];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=opt_sig_seq[1][2];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]==0)
					Temp_event.phase=5;
				if (opt_sig_plan[1][2]==0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=6;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R2.InsertRear(Temp_event);	
				//force off phase 8
				Temp_event.time=opt_sig_plan[1][0]+Yellow[6]+Red[6]+opt_sig_plan[1][1];
				Temp_event.phase=8;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R2.InsertRear(Temp_event);
			}
		}
		else
		{
			//hold phase 7
			Temp_event.time=opt_sig_plan[1][0];
			Temp_event.phase=7;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			if(opt_sig_plan[1][2]!=0 || opt_sig_plan[1][3]!=0)
			{
				//call phase in next barrier: 5 or 6
				Temp_event.time=opt_sig_plan[1][0];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=opt_sig_seq[1][2];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]==0)
					Temp_event.phase=5;
				if (opt_sig_plan[1][2]==0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=6;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R2.InsertRear(Temp_event);
				//force off phase 7
				Temp_event.time=opt_sig_plan[1][0];
				Temp_event.phase=7;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R2.InsertRear(Temp_event);
			}
		}
	}
	
	if(cur_phase[1]==8)
	{
		if(opt_sig_plan[1][0]!=0)  
		{
			//hold phase 8
			Temp_event.time=opt_sig_plan[1][1];
			Temp_event.phase=8;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			//call phase 7
			Temp_event.time=opt_sig_plan[1][1];
			Temp_event.phase=7;
			Temp_event.action=PHASE_VEH_CALL;
			Eventlist_R2.InsertRear(Temp_event);
			//force off phase 8
			Temp_event.time=opt_sig_plan[1][1];
			Temp_event.phase=8;
			Temp_event.action=PHASE_FORCEOFF;
			Eventlist_R2.InsertRear(Temp_event);
			//hold phase 7
			Temp_event.time=opt_sig_plan[1][1]+Yellow[7]+Red[7]+opt_sig_plan[1][0];
			Temp_event.phase=7;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			if(opt_sig_plan[1][2]!=0 || opt_sig_plan[1][3]!=0)
			{
				//call phase in next barrier: 5 or 6
				Temp_event.time=opt_sig_plan[1][1]+Yellow[7]+Red[7]+opt_sig_plan[1][0];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=opt_sig_seq[1][2];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]==0)
					Temp_event.phase=5;
				if (opt_sig_plan[1][2]==0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=6;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R2.InsertRear(Temp_event);	
				//force off phase 7
				Temp_event.time=opt_sig_plan[1][1]+Yellow[7]+Red[7]+opt_sig_plan[1][0];
				Temp_event.phase=7;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R2.InsertRear(Temp_event);
			}
		}
		else
		{
			//hold phase 8
			Temp_event.time=opt_sig_plan[1][1];
			Temp_event.phase=8;
			Temp_event.action=PHASE_HOLD;
			Eventlist_R2.InsertRear(Temp_event);
			if(opt_sig_plan[1][2]!=0 || opt_sig_plan[1][3]!=0)
			{
				//call phase in next barrier: 5 or 6
				Temp_event.time=opt_sig_plan[1][1];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=opt_sig_seq[1][2];
				if (opt_sig_plan[1][2]!=0 && opt_sig_plan[1][3]==0)
					Temp_event.phase=5;
				if (opt_sig_plan[1][2]==0 && opt_sig_plan[1][3]!=0)
					Temp_event.phase=6;
				Temp_event.action=PHASE_VEH_CALL;
				Eventlist_R2.InsertRear(Temp_event);
				//force off phase 8
				Temp_event.time=opt_sig_plan[1][1];
				Temp_event.phase=8;
				Temp_event.action=PHASE_FORCEOFF;
				Eventlist_R2.InsertRear(Temp_event);
			}
		}
	}
}
              
int Conflit_call(int currphase[2], int skipphase[8])
{
	for(int i=0;i<8;i++)
	{
		if(skipphase[i]==1)   //this phase has vehicle
		{
			if((i+1)!=currphase[0] && (i+1)!=currphase[1])
			{
				return 1;
			}
		}
	}
	
	return 0;
}

void UnpackTrajData1(char* ablob)
{
	int No_Veh;
	int i,j;
	int offset;
	offset=0;
	unsigned short   tempUShort; // temp values to hold data in final format
	long    tempLong;
	unsigned char   byteA;  // force to unsigned this time,
	unsigned char   byteB;  // we do not want a bunch of sign extension 
	unsigned char   byteC;  // math mucking up our combine logic
	unsigned char   byteD;
	
	//Header
	byteA = ablob[offset+0];
	byteB = ablob[offset+1];
	int temp = (int)(((byteA << 8) + (byteB))); // in fact unsigned
	offset = offset + 2;
	
	//cout<<temp<<endl;
	
	//id
	temp = (char)ablob[offset];
	offset = offset + 1; // move past to next item
	//cout<<temp<<endl;
	
	
	//Do vehicle number
	byteA = ablob[offset+0];
	byteB = ablob[offset+1];
	No_Veh = (int)(((byteA << 8) + (byteB))); // in fact unsigned
	offset = offset + 2;
	
	//cout<<No_Veh<<endl;
	
	//Do each vehicle
	for(i=0;i<No_Veh;i++)
	{
		ConnectedVehicle TempVeh;
		//Do Veh ID
		byteA = ablob[offset+0];
		byteB = ablob[offset+1];
		TempVeh.TempID = (int)(((byteA << 8) + (byteB))); // in fact unsigned
		offset = offset + 2;

		//do speed
		byteA = ablob[offset+0];
		byteB = ablob[offset+1];
		byteC = ablob[offset+2];
		byteD = ablob[offset+3];
		tempLong = (unsigned long)((byteA << 24) + (byteB << 16) + (byteC << 8) + (byteD));
		TempVeh.Speed = (tempLong /  DEG2ASNunits); // convert and store as float
		offset = offset + 4;
		
		//do distance to stop bar
		byteA = ablob[offset+0];
		byteB = ablob[offset+1];
		byteC = ablob[offset+2];
		byteD = ablob[offset+3];
		tempLong = (unsigned long)((byteA << 24) + (byteB << 16) + (byteC << 8) + (byteD));
		TempVeh.stopBarDistance = (tempLong /  DEG2ASNunits); // convert and store as float
		offset = offset + 4;
		
		//do acceleration
		byteA = ablob[offset+0];
		byteB = ablob[offset+1];
		byteC = ablob[offset+2];
		byteD = ablob[offset+3];
		tempLong = (unsigned long)((byteA << 24) + (byteB << 16) + (byteC << 8) + (byteD));
		TempVeh.acceleration = (tempLong /  DEG2ASNunits); // convert and store as float
		offset = offset + 4;
		
		//do approach
		TempVeh.approach = (char)ablob[offset];
	    offset = offset + 1; // move past to next item
		
		//do lane
		TempVeh.lane = (char)ablob[offset];
	    offset = offset + 1; // move past to next item
		
		//do req_phase
		TempVeh.req_phase = (char)ablob[offset];
	    offset = offset + 1; // move past to next item
		
		//do stop time
		byteA = ablob[offset+0];
		byteB = ablob[offset+1];
		byteC = ablob[offset+2];
		byteD = ablob[offset+3];
		tempLong = (unsigned long)((byteA << 24) + (byteB << 16) + (byteC << 8) + (byteD));
		TempVeh.time_stop = (tempLong); // convert and store as float
		offset = offset + 4;
		
		//cout<<"E_Offset["<<j<<"] is:"<<TempVeh.E_Offset[j]<<endl;
		//cout<<"Done with one vehicle"<<endl;
		
		//Here reflects the penetration rate!!!!!!!!!!!!!!!!!!!!!!!!!!! Add only half of the vehicles
	//	if (penetration>0.99)  //%100 penetration rate
	//	{
		trackedveh.InsertRear(TempVeh); 
	//	}
	//	if (penetration>0.74 && penetration<0.76) //75% penetration rate
	//	{
	//		if (TempVeh.TempID%4==3 || TempVeh.TempID%4==1 ||TempVeh.TempID%4==2)
	//			trackedveh.InsertRear(TempVeh); 
	//	}
	//	if (penetration>0.49 && penetration<0.51)	//50% penetration rate
	//	{
	//		if (TempVeh.TempID%2==1)
	//			trackedveh.InsertRear(TempVeh); 
	//	}
	//	if (penetration>0.24 && penetration<0.26)	//25% penetration rate
	//	{
	//		if (TempVeh.TempID%4==1)
	//			trackedveh.InsertRear(TempVeh); 
	//	} 
	}
}

void get_lane_no() //Yiheng add 09/19/2014
{
    fstream fs;

    fs.open(Lane_No_File_Name);

    char temp[128];
	
	string temp_string;

    getline(fs,temp_string);  //First line is comment
	getline(fs,temp_string);  //Second line contains information


    if(temp_string.size()!=0)
    {
		char tmp[128];
		strcpy(tmp,temp_string.c_str());		
		sscanf(tmp,"%d %d %d %d %d %d %d %d",&LaneNo[0],&LaneNo[1],&LaneNo[2],&LaneNo[3],&LaneNo[4],&LaneNo[5],&LaneNo[6],&LaneNo[7]);
    }
    else
    {
        sprintf(temp,"Reading Lane_Phase_Mapping_File problem");
        cout<<temp<<endl;
        outputlog(temp);
        exit(0);
    }

    fs.close();
}

void ReadSignalParameters(char *ConfigFile)
{
	fstream fs;
	fs.open(ConfigFile);
	string temp_string;
	char temp[128];
	//read number of phases
	getline(fs,temp_string);
	strcpy(temp,temp_string.c_str());
	sscanf(temp,"%*s %d",&Phase_Num);
	//read phase sequence
	getline(fs,temp_string);
	strcpy(temp,temp_string.c_str());
	sscanf(temp,"%*s %d %d %d %d %d %d %d %d",&phase_seq[0],&phase_seq[1],&phase_seq[2],&phase_seq[3],&phase_seq[4],&phase_seq[5],&phase_seq[6],&phase_seq[7]);
	//read min green time
	getline(fs,temp_string);
	strcpy(temp,temp_string.c_str());
	sscanf(temp,"%*s %d %d %d %d %d %d %d %d",&MinGreen[0],&MinGreen[1],&MinGreen[2],&MinGreen[3],&MinGreen[4],&MinGreen[5],&MinGreen[6],&MinGreen[7]);
	//read yellow time
	getline(fs,temp_string);
	strcpy(temp,temp_string.c_str());
	sscanf(temp,"%*s %d %d %d %d %d %d %d %d",&Yellow[0],&Yellow[1],&Yellow[2],&Yellow[3],&Yellow[4],&Yellow[5],&Yellow[6],&Yellow[7]);
	//read red time
	getline(fs,temp_string);
	strcpy(temp,temp_string.c_str());
	sscanf(temp,"%*s %d %d %d %d %d %d %d %d",&Red[0],&Red[1],&Red[2],&Red[3],&Red[4],&Red[5],&Red[6],&Red[7]);
	//read max green time
	getline(fs,temp_string);
	strcpy(temp,temp_string.c_str());
	sscanf(temp,"%*s %d %d %d %d %d %d %d %d",&MaxGreen[0],&MaxGreen[1],&MaxGreen[2],&MaxGreen[3],&MaxGreen[4],&MaxGreen[5],&MaxGreen[6],&MaxGreen[7]);
	//read ped walk time
	getline(fs,temp_string);
	strcpy(temp,temp_string.c_str());
	sscanf(temp,"%*s %d %d %d %d %d %d %d %d",&PedWalk[0],&PedWalk[1],&PedWalk[2],&PedWalk[3],&PedWalk[4],&PedWalk[5],&PedWalk[6],&PedWalk[7]);
	//read ped clear time
	getline(fs,temp_string);
	strcpy(temp,temp_string.c_str());
	sscanf(temp,"%*s %d %d %d %d %d %d %d %d",&PedClr[0],&PedClr[1],&PedClr[2],&PedClr[3],&PedClr[4],&PedClr[5],&PedClr[6],&PedClr[7]);
		
	fs.close();
}

int Check_Ped_Phase_Info()
{
	int i;
	int Ped_Phase_on[8]={0};
	int Ped_Phase_call[8]={0};
	
	int ped_status=0;	
	if(Ped_Info[0]!=0 ||Ped_Info[1]!=0)
		ped_status=1;
	
	cout<<"Ped_Info is:"<<Ped_Info[0]<<" "<<Ped_Info[1]<<endl;
	
	cout<<"Ped_Phase_on: ";
	
	for(i=7;i>=0;i--)
	{
		if(Ped_Info[0]-pow(2.0,i*1.0)>=0)
		{
			Ped_Phase_on[i]=1;
			Ped_Info[0]-=pow(2.0,i*1.0);
		}
		cout<<Ped_Phase_on[i]<<" ";
	}
	cout<<endl;
	
	cout<<"Ped_Phase_call: ";
	for(i=7;i>=0;i--)
	{
		if(Ped_Info[1]-pow(2.0,i*1.0)>=0)
		{
			Ped_Phase_call[i]=1;
			Ped_Info[1]-=pow(2.0,i*1.0);
		}
		cout<<Ped_Phase_call[i]<<" ";
	}
	cout<<endl;
	
	for(i=0;i<8;i++)
	{
		if(Ped_Phase_on[i]==0 && Ped_Phase_call[i]==0)
			Ped_Phase_Considered[i]=0;
		else
			Ped_Phase_Considered[i]=1;		
	}
	
	return ped_status;
	
}

void Pack_Event_List(byte* tmp_event_data,int &size)
{	
	int i,j;
	int offset=0;
	byte*   pByte;      // pointer used (by cast)to get at each byte 
                            // of the shorts, longs, and blobs
    byte    tempByte;   // values to hold data once converted to final format
	unsigned short   tempUShort;
    long    tempLong;
    //header 2 bytes
	tmp_event_data[offset]=0xFF;
	offset+=1;
	tmp_event_data[offset]=0xFF;
	offset+=1;
	//MSG ID: 0x03 for signal event data send to Signal Control Interface
	tmp_event_data[offset]=0x03;
	offset+=1;
	//No. events in R1
	int No_Event_R1= Eventlist_R1.ListSize();
	tempUShort = (unsigned short)No_Event_R1;
	pByte = (byte* ) &tempUShort;
    tmp_event_data[offset+0] = (byte) *(pByte + 1); 
    tmp_event_data[offset+1] = (byte) *(pByte + 0); 
	offset = offset + 2;
	//Events in R1
	Eventlist_R1.Reset();
	while(!Eventlist_R1.EndOfList())
	{
		//Time 
		tempLong = (long)(Eventlist_R1.Data().time * DEG2ASNunits); 
		pByte = (byte* ) &tempLong;
		tmp_event_data[offset+0] = (byte) *(pByte + 3); 
		tmp_event_data[offset+1] = (byte) *(pByte + 2); 
		tmp_event_data[offset+2] = (byte) *(pByte + 1); 
		tmp_event_data[offset+3] = (byte) *(pByte + 0); 
		offset = offset + 4;
		//phase
		tempUShort = (unsigned short)Eventlist_R1.Data().phase;
		pByte = (byte* ) &tempUShort;
		tmp_event_data[offset+0] = (byte) *(pByte + 1); 
		tmp_event_data[offset+1] = (byte) *(pByte + 0); 
		offset = offset + 2;
		//action
		tempUShort = (unsigned short)Eventlist_R1.Data().action;
		pByte = (byte* ) &tempUShort;
		tmp_event_data[offset+0] = (byte) *(pByte + 1); 
		tmp_event_data[offset+1] = (byte) *(pByte + 0); 
		offset = offset + 2;
		Eventlist_R1.Next();
	}
	//No. events in R2
	int No_Event_R2= Eventlist_R2.ListSize();
	tempUShort = (unsigned short)No_Event_R2;
	pByte = (byte* ) &tempUShort;
    tmp_event_data[offset+0] = (byte) *(pByte + 1); 
    tmp_event_data[offset+1] = (byte) *(pByte + 0); 
	offset = offset + 2;
	//Events in R1
	Eventlist_R2.Reset();
	while(!Eventlist_R2.EndOfList())
	{
		//Time 
		tempLong = (long)(Eventlist_R2.Data().time * DEG2ASNunits); 
		pByte = (byte* ) &tempLong;
		tmp_event_data[offset+0] = (byte) *(pByte + 3); 
		tmp_event_data[offset+1] = (byte) *(pByte + 2); 
		tmp_event_data[offset+2] = (byte) *(pByte + 1); 
		tmp_event_data[offset+3] = (byte) *(pByte + 0); 
		offset = offset + 4;
		//phase
		tempUShort = (unsigned short)Eventlist_R2.Data().phase;
		pByte = (byte* ) &tempUShort;
		tmp_event_data[offset+0] = (byte) *(pByte + 1); 
		tmp_event_data[offset+1] = (byte) *(pByte + 0); 
		offset = offset + 2;
		//action
		tempUShort = (unsigned short)Eventlist_R2.Data().action;
		pByte = (byte* ) &tempUShort;
		tmp_event_data[offset+0] = (byte) *(pByte + 1); 
		tmp_event_data[offset+1] = (byte) *(pByte + 0); 
		offset = offset + 2;
		Eventlist_R2.Next();	
	}
	size=offset;
}

int Complete_Barrier()
{
	//phase 1,2,3,4
	for(int i=0;i<4;i++)
	{
		if(skip_phase[i]==1) //phase i not skip
		{
			if(phase_seq[i+4]==0)  //phase i+4 is not active
			{
				skip_phase[i+4]=1;  //add phase i+4
			}
		}
	}
	
	//phase 5,6,7,8
	for(int i=7;i>3;i--)
	{
		if(skip_phase[i]==1) //phase i not skip
		{
			if(phase_seq[i-4]==0)  //phase i+4 is not active
			{
				skip_phase[i-4]=1;  //add phase i+4
			}
		}
	}	
}


int Checkconflict(int CurPhase[2])
{
	int conflict=0;
	if(CurPhase[0]==1 ||CurPhase[0]==2)  //P11
	{
		if (CurPhase[1]!=5 && CurPhase[1]!=6)
			conflict=1;
	}
	if(CurPhase[0]==3 ||CurPhase[0]==4)  //P11
	{
		if (CurPhase[1]!=7 && CurPhase[1]!=8)
			conflict=1;
	}
	if(CurPhase[0]==5 ||CurPhase[0]==6)  //P11
	{
		if (CurPhase[1]!=1 && CurPhase[1]!=2)
			conflict=1;
	}
	if(CurPhase[0]==7 ||CurPhase[0]==8)  //P11
	{
		if (CurPhase[1]!=3 && CurPhase[1]!=4)
			conflict=1;
	}
	
	return conflict;
}

int ModifyCurPhase(int CurrPhase[2], int phase_seq[8])
{
	if(phase_seq[CurrPhase[0]+4-1]==0)  //missing phase is in ring 2
		CurrPhase[1]=CurrPhase[0]+4;    //change phase in ring 2
	if(phase_seq[CurrPhase[1]-4-1]==0)  //missing phase is in ring 1
		CurrPhase[0]=CurrPhase[1]-4;    //change phase in ring 1
}
